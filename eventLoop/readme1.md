##js是单线程的吗
js是单线程不是很对，主线程是单线程，setTimeout会多开一条线程
##事件循环
通过异步执行任务的方式来解决js单线程阻塞的问题  
宏任务-微任务(当前宏任务产生的微任务)是一个循环，
##为什么是单线程
多线程会引起并发问题(同时对一个dom进行修改和删除，引起冲突)
##为什么需要异步
因为js是单线程，容易造成阻塞问题，用户体验上体现为卡顿

##宏任务
* script
* setTimeout
* setInterval
* postMessage
* I/O
* UI交互事件
##微任务
* new Promise().then
* MutationObserver(html5 新特性)
不同的类型会进入不同的事件队列(宏任务队列和微任务队列)
##node时间循环

##调用栈
##时间轮询
##任务队列
先进先出的数据结构

##浏览器事件循环
#####执行栈
同步代码会加入到执行栈中，然后依次执行
#####事件队列
异步事件将放到事件队列(微任务队列和宏任务队列)中，待执行栈中的同步任务执行完毕，在从队列中取出事件放到执行栈中执行

##NODEJS事件循环
#####libuv引擎事件循环模型
```
timers - I/O callbacks- idle,prepare - poll- check - close callbacks
```
######每一个模块代表事件循环的一个阶段
#####事件循环顺序
* 轮询阶段(poll)
* 检查阶段(check)
* 关闭事件回调阶段(close callback)
* 定时器检测阶段(timers)
* I/O事件回调阶段(I/O callbacks)
* 闲置阶段(idle, prepare)
* 轮询阶段...

####调用堆栈
调用堆栈是一个LIFO队列(后进先出)，事件循环不断的检查调用堆栈，看是否有需要执行的函数